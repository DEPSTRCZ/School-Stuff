<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bubbles</title>
    <style>
      body {
        background: rgb(80, 100, 120);
      }

      #cnvs {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        z-index: -2;
      }
    </style>
  </head>
  <body>
    <canvas id="cnvs"></canvas>
    <script>
        const canvas = document.getElementById("cnvs")
        const ctx = canvas.getContext("2d")
        let mouseDown = false;
        let cursor = {x: 0, y: 0, radius: 50}

        const maxRadius = 50
        const minRadius = 10
        const maxSpeed = 0.5
        let dropCount = 0
        let drops = []

        canvas.addEventListener('mousedown',function(event) {
	        mouseDown = true;
        });
        canvas.addEventListener('mouseup', function(event) {
            mouseDown = false;
        });
        canvas.addEventListener("mousemove", (mouse) => {
            cursor.x = mouse.clientX, cursor.y = mouse.clientY
        })

        class Drop {
            constructor() {
                this.radius = Math.random() * maxRadius + minRadius
                this.x = Math.random() * canvas.width 
                this.y = Math.random() * canvas.height
                this.dx = (Math.random() * maxSpeed - maxSpeed / 2) * (1 + Math.random() * 1.5 - 0.75);
                this.dy = (Math.random() * maxSpeed - maxSpeed / 2) * (1 + Math.random() * 1.5 - 0.75);
                this.color = `rgb(${Math.random() * 255},${Math.random() * 255},${Math.random() * 255})`
                this.coliding = false
                this.last_center_distance = 0
            }
            move() {

                if (this.x + this.radius > canvas.width && this.dx > 0) this.dx *= -1
                if (this.x - this.radius < 0 && this.dx < 0) this.dx *= -1

                if (this.y + this.radius > canvas.height && this.dy > 0) this.dy *= -1
                if ( this.y - this.radius < 0 && this.dy < 0) this.dy *= -1



                /*if (checkCollision(this)) {
                    console.log("colide")
                    if (!this.coliding) {
                        this.coliding = true
                        this.dx *= -1;
                        this.dy *= -1;
                    }

                }*/
                this.x += this.dx
                this.y += this.dy

                
            }

            draw(ctx) {
                ctx.beginPath()
                ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false)
                ctx.fillStyle = this.color
                ctx.fill()
                ctx.closePath()



                if (cursor.x && cursor.y) {
                    ctx.beginPath()
                    ctx.arc(cursor.x, cursor.y, cursor.radius, 0, 2 * Math.PI, false)
                    ctx.fillStyle = `rgb(220,120,200,0.009)`
                    ctx.fill()
                    ctx.closePath()

                    ctx.font = "15px Arial"; // Adjust font size and family as needed
                    ctx.fillStyle = "white"; // Adjust text color as needed
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(`${Math.floor(cursor.x+50)},${Math.floor(cursor.y+50)},${Math.floor(this.dy)}`, cursor.x, cursor.y);
                }



                ctx.font = "15px Arial"; // Adjust font size and family as needed
                ctx.fillStyle = "white"; // Adjust text color as needed
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(`${Math.floor(this.x+this.radius)},${Math.floor(this.y-this.radius)}| ${Math.floor(this.dx)},${Math.floor(this.dy)} - ${this.coliding}`, this.x, this.y);
            }
        }
        /*function checkCollision(ball) {
            // credit https://www.reddit.com/r/javascript/comments/9rqgj4/collision_detection_between_balls/, https://bytesnbits.co.uk/bounding-ball-collision-detection-game-coding-tutorial/

            const d_sqr = (cursor.x - ball.x) ** 2 + (cursor.y - ball.y) ** 2;
            const r_sqr = (cursor.radius + ball.radius) ** 2;
            return d_sqr <= r_sqr;
        }*/
        function checkCollision(ball) {
            const rSum = cursor.radius+100 + ball.radius;
            const dx = ball.x - cursor.x;
            const dy = ball.y - cursor.y;
            return [rSum * rSum > dx * dx + dy * dy, rSum - Math.sqrt(dx * dx + dy * dy)];
        }
        function resizeCanvas() {
            canvas.width = window.innerWidth
            canvas.height = window.innerHeight
            dropCount = 190//Math.round((canvas.width * canvas.height) / 100000 )
            drops = []
            for (let i = 0; i < dropCount; i++) {
            drops.push(new Drop())
            }

        }

        window.onresize = resizeCanvas
        resizeCanvas()

        function animateCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height)

            let c = 1;
            //for (const drop of drops) {
            for (let i = 0; i < drops.length-1; i++) {
                const ball = drops[i];
                //console.log(drop)
                const collision = checkCollision(ball)
                if (collision[0]) {
                    console.log("collision",ball.last_center_distance, collision[1])
                    if (collision[1] >= ball.last_center_distance) {
                            console.log("flip")
                            ball.dx *= -1
                            ball.dy *= -1
                            
                            
                        }
                    if (!ball.coliding) {
 
                        ball.coliding = true
                        
                    }
                    ball.last_center_distance = collision[1]
                } else {
                    ball.coliding = false
                }

            //for (const drop2 of drops) {
            for (let j = 0; j < drops.length; j++) {
                if (checkCollision(drops[i])) {
                //console.log("collision")
                //drops[i].dx *= -1
                //drops[i].dy *= -1
                }
                //else console.log("no collision")
            }
            drops[i].draw(ctx)
            drops[i].move()
            }
            /*for (let i = 0; i < drops.length; i++) {
            const drop = drops[i];
            //console.log(drop)
            
            let j = i + 1

            for (let compareIndex = i + 1; compareIndex < drops.length; compareIndex++) {
                console.log(1)
                const drop2 = drops[j];
                console.log(drop, drop2)
                if (checkCollision(drop, drop2)) {
                    console.log("collision between", i, "and", compareIndex);
                } else {
                    console.log("no collision");
                }
            }
            drop.draw(ctx)
            drop.move()
            }*/
        


            requestAnimationFrame(animateCanvas)
        }

      animateCanvas()
    </script>
  </body>
</html>