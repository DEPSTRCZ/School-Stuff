<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bubbles</title>
    <style>
      body {
        background: rgb(80, 100, 120);
      }

      #cnvs {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        z-index: -2;
      }
      .settings-card {
        position: fixed;
        top: 0;
        right: 0;
        width: 15vw;
        height: 10vh;
        background: rgba(0,0,0,0.5);
        z-index: 100;
      }
    </style>
  </head>
  <body>
    <canvas id="cnvs"></canvas>
    <div class="settings-card">
        <h1>Settings</h1>
        <label for="lines">Lines</label>
        <input type="checkbox" id="lines" name="lines" value="lines">
        <label for="color">Color</label>
        <input type="color" id="color" name="color" value="#ff0000">
        <label for="speed">Speed</label>
        <input type="range" id="speed" name="speed" min="0" max="10" value="5">
        <label for="lt">LineThickness</label>
        <input type="range" id="lt" name="lt" min="0" max="10" value="5">
    </div>
    <script>
        const canvas = document.getElementById("cnvs")
        const ctx = canvas.getContext("2d")
        let cursor = {x: 0, y: 0, radius: 50}
        let color = "#ff0000"

        const maxRadius = 50
        const minRadius = 10
        const maxBounceSpeed = 5.5
        const maxSpeed = 0.5

        const LineDistance = Math.min(canvas.width, canvas.height) * 0.8
        let LineThickness = 0
        let lines = false

        let dropCount = 0
        let drops = []

        canvas.addEventListener("mousemove", (mouse) => {
            cursor.x = mouse.clientX, cursor.y = mouse.clientY
        })
        document.getElementById("lines").addEventListener("change", (e) => {
            lines = e.target.checked
        })
        document.getElementById("lt").addEventListener("change", (e) => {
            LineThickness = e.target.value
        })
        document.getElementById("color").addEventListener("change", (e) => {
            color = e.target.value
            resizeCanvas()
        })

        function createRandomShade(hexColor) {
            const [r, g, b] = hexColor.match(/\w{2}/g).map(hex => parseInt(hex, 16));

            const baseBrightnessFactor = Math.random() * 0.6 - 0.3; // Small base adjustment

            // Generate slight variation for each instance
            const instanceVariation = Math.random() * 0.05 - 0.025;

            const adjustedR = Math.round(Math.max(0, Math.min(255, r + (r * (baseBrightnessFactor + instanceVariation)))));
            const adjustedG = Math.round(Math.max(0, Math.min(255, g + (g * (baseBrightnessFactor + instanceVariation)))));
            const adjustedB = Math.round(Math.max(0, Math.min(255, b + (b * (baseBrightnessFactor + instanceVariation)))));

            const shadeHex = `#${adjustedR.toString(16).padStart(2, '0')}${adjustedG.toString(16).padStart(2, '0')}${adjustedB.toString(16).padStart(2, '0')}`;

            return shadeHex;
        }

        class Drop {
            constructor() {
                this.radius = Math.random() * maxRadius + minRadius
                this.x = Math.random() * canvas.width 
                this.y = Math.random() * canvas.height
                this.dx = (Math.random() * maxSpeed - maxSpeed / 2) * (1 + Math.random() * 1.5 - 0.75);
                this.dy = (Math.random() * maxSpeed - maxSpeed / 2) * (1 + Math.random() * 1.5 - 0.75);
                this.color = createRandomShade(color)
            }
            move() {

                if (this.x + this.radius > canvas.width && this.dx > 0) this.dx *= -1
                if (this.x - this.radius < 0 && this.dx < 0) this.dx *= -1

                if (this.y + this.radius > canvas.height && this.dy > 0) this.dy *= -1
                if ( this.y - this.radius < 0 && this.dy < 0) this.dy *= -1

                this.x += this.dx
                this.y += this.dy
            }

            draw(ctx) {
                ctx.beginPath()
                ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false)
                ctx.fillStyle = this.color
                ctx.fill()
                ctx.closePath()



                if (cursor.x && cursor.y) {
                    ctx.beginPath()
                    ctx.arc(cursor.x, cursor.y, cursor.radius, 0, 2 * Math.PI, false)
                    ctx.fillStyle = `rgb(220,120,200,0.009)`
                    ctx.fill()
                    ctx.closePath()

                    ctx.font = "15px Arial"; // Adjust font size and family as needed
                    ctx.fillStyle = "white"; // Adjust text color as needed
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                }



                ctx.font = "15px Arial"; // Adjust font size and family as needed
                ctx.fillStyle = "white"; // Adjust text color as needed
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
            }
            drawLine(ctx) {
                ctx.beginPath()
                ctx.moveTo(this.x, this.y)
                ctx.lineTo(cursor.x, cursor.y)
                ctx.strokeStyle = "white"
                ctx.stroke()
                ctx.closePath()
            }
        }

        // Explain: (URL)
        //modifed & borrowed from: https://codepen.io/ztyler/pen/LergVR
        function checkCollision(ball) {
            const rSum = cursor.radius + ball.radius;
            const deltax = ball.x - cursor.x;
            const deltay = ball.y - cursor.y;
            //            pythag
            const colided = rSum * rSum > deltax * deltax + deltay * deltay; // avoid calc square root when no colision
            if (!colided) return [false, 0];
            return [colided, rSum - Math.sqrt(deltax * deltax + deltay * deltay)];
        }
        function resizeCanvas() {
            canvas.width = window.innerWidth
            canvas.height = window.innerHeight
            dropCount = Math.round((canvas.width * canvas.height) / 10000 )
            drops = []
            for (let i = 0; i < dropCount; i++) {
            drops.push(new Drop())
            }

        }

        window.onresize = resizeCanvas
        resizeCanvas()

        function animateCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height)

            for (let i = 0; i < drops.length-1; i++) {
                const ball = drops[i];
                const collision = checkCollision(ball)

                if (collision[0]) {
                    const rSum = cursor.radius + ball.radius;
                    const ratio = rSum / (rSum - collision[1]); // (poměr zvětšení) nevím překald lol
                    const target_deltax = ratio * (ball.x - cursor.x); // násobíme poměrem velikosti  na cil x
                     const target_deltay = ratio * (ball.y - cursor.y); // násobíme poměrem velikosti  na cil y
                    ball.x = target_deltax + cursor.x;
                    ball.y = target_deltay + cursor.y;

                    if (target_deltax > 0 && ball.dx < 0) ball.dx *= -1;
                    if (target_deltax < 0 && ball.dx > 0) ball.dx *= -1;

                    if (maxBounceSpeed > Math.abs(ball.dx) || maxBounceSpeed > Math.abs(ball.dy)) {
                        ball.dx *= 1.2;
                        ball.dy *= 1.2;
                    };
                } else {
                    if (maxSpeed < Math.abs(ball.dx) || maxSpeed < Math.abs(ball.dy)) {
                        ball.dx *= 0.99;
                        ball.dy *= 0.99;
                    };
                }

                if (lines) {
                    for (let j = i+1; j < drops.length; j++) {
                        const ball2 = drops[j];
                        if (Math.abs(ball.x-ball2.x) < LineDistance && Math.abs(ball.y-ball2.y) < LineDistance) {
                            ctx.beginPath()
                            ctx.moveTo(ball.x, ball.y)
                            ctx.lineTo(ball2.x, ball2.y)
                            ctx.strokeStyle = "white"
                            ctx.lineWidth = LineThickness
                            ctx.stroke()
                            ctx.closePath()

                        }
                    }
                }

                drops[i].draw(ctx)
                drops[i].move()
            }
            requestAnimationFrame(animateCanvas)
        }

        animateCanvas()
    </script>
  </body>
</html>